Index: src/inputPlugins/mp3_plugin.c
===================================================================
--- src/inputPlugins/mp3_plugin.c	(revision 3712)
+++ src/inputPlugins/mp3_plugin.c	(working copy)
@@ -35,6 +35,7 @@
 #endif
 #include "../log.h"
 #include "../utils.h"
+#include "../replayGain.h"
 #include "../tag.h"
 
 #include <stdio.h>
@@ -207,7 +209,57 @@
 }
 
 #ifdef HAVE_ID3TAG
-static MpdTag * mp3_parseId3Tag(mp3DecodeData * data, signed long tagsize) {
+ReplayGainInfo * getId3ReplayGainInfo(struct id3_tag * tag)
+{
+	id3_utf8_t *frame_value;
+	ReplayGainInfo * ret = NULL;
+	int found = 0;
+
+	// if we find replay gain info -- make a new replayGainInfo
+	// and then fill it with the data
+
+	ret = newReplayGainInfo();
+	
+	frame_value = id3_tag_findframe_user(tag, "replaygain_track_gain");
+	if (frame_value) {
+		found = 1;
+		ret->trackGain = atof(frame_value);
+		free(frame_value);
+	}
+	frame_value = id3_tag_findframe_user(tag, "replaygain_track_peak");
+	if (frame_value) {
+		found = 1;
+		ret->trackPeak = atof(frame_value);
+		free(frame_value);
+	}
+	frame_value = id3_tag_findframe_user(tag, "replaygain_album_gain");
+	if (frame_value) {
+		found = 1;
+		ret->albumGain = atof(frame_value);
+		free(frame_value);
+	} else {
+		ret->albumGain = ret->trackGain;
+	}
+	
+	frame_value = id3_tag_findframe_user(tag, "replaygain_album_peak");
+	if (frame_value) {
+		found = 1;
+		ret->albumPeak = atof(frame_value);
+		free(frame_value);
+	} else {
+		ret->albumPeak = ret->trackPeak;
+	}
+
+	if (found == 0) {
+		free(ret);
+		return NULL;
+	}
+	else {
+		return ret;
+	}
+}
+
+static void mp3_parseId3Tag(mp3DecodeData * data, signed long tagsize, MpdTag ** mpdTag, ReplayGainInfo **replayGainInfo) {
 	MpdTag * ret = NULL;
 	struct id3_tag * id3Tag = NULL;
 	id3_length_t count;
@@ -251,17 +303,21 @@
 	id3Tag = id3_tag_parse(id3_data, tagsize);
  
 	if(id3Tag) {
-		ret = parseId3Tag(id3Tag);
+		*mpdTag = parseId3Tag(id3Tag);
+		if (replayGainInfo){
+			*replayGainInfo = getId3ReplayGainInfo(id3Tag);
+		}
 		id3_tag_delete(id3Tag);
 	}
 
 fail:
 	if(allocated) free(allocated);
-	return ret;
+
+	if (mpdTag) *mpdTag = ret;
 }
 #endif
 
-int decodeNextFrameHeader(mp3DecodeData * data, MpdTag ** tag) {
+int decodeNextFrameHeader(mp3DecodeData * data, MpdTag ** tag, ReplayGainInfo **replayGainInfo) {
 	if((data->stream).buffer==NULL || (data->stream).error==MAD_ERROR_BUFLEN) {
 		if(fillMp3InputBuffer(data) < 0) {
 			return DECODE_BREAK;
@@ -279,13 +335,13 @@
 
 			if(tagsize>0) {
 				if(tag && !(*tag)) {
-					*tag = mp3_parseId3Tag(data, tagsize);
-					
+					mp3_parseId3Tag(data, tagsize, tag, replayGainInfo);
 				}
 				else {
 					mad_stream_skip(&(data->stream),
 							tagsize);
 				}
+
 				return DECODE_CONT;
 			}
 		}
@@ -408,7 +464,7 @@
 }
 
 int decodeFirstFrame(mp3DecodeData * data, DecoderControl * dc,
-		MpdTag ** tag) 
+		MpdTag ** tag, ReplayGainInfo **replayGainInfo) 
 {
 	struct xing xing;
 	int ret;
@@ -419,7 +475,7 @@
 
 	while(1) {
 		skip = 0;
-		while((ret = decodeNextFrameHeader(data, tag))==DECODE_CONT && 
+		while((ret = decodeNextFrameHeader(data, tag, replayGainInfo))==DECODE_CONT && 
 				(!dc || !dc->stop));
 		if(ret==DECODE_SKIP) skip = 1;
 		else if(ret==DECODE_BREAK || (dc && dc->stop)) return -1;
@@ -485,7 +541,7 @@
 
         if(openInputStream(&inStream, file) < 0) return -1;
 	initMp3DecodeData(&data,&inStream);
-	if(decodeFirstFrame(&data, NULL, NULL)<0) ret = -1;
+	if(decodeFirstFrame(&data, NULL, NULL,NULL)<0) ret = -1;
 	else ret = data.totalTime+0.5;
 	mp3DecodeDataFinalize(&data);
 	closeInputStream(&inStream);
@@ -494,11 +550,11 @@
 }
 
 int openMp3FromInputStream(InputStream * inStream, mp3DecodeData * data,
-		DecoderControl * dc, MpdTag ** tag) 
+		DecoderControl * dc, MpdTag ** tag, ReplayGainInfo **replayGainInfo) 
 {
 	initMp3DecodeData(data, inStream);
 	*tag = NULL;
-	if(decodeFirstFrame(data, dc, tag)<0) {
+	if(decodeFirstFrame(data, dc, tag, replayGainInfo)<0) {
 		mp3DecodeDataFinalize(data);
 		if(tag && *tag) freeMpdTag(*tag);
 		return -1;
@@ -507,7 +563,7 @@
 	return 0;
 }
 
-int mp3Read(mp3DecodeData * data, OutputBuffer * cb, DecoderControl * dc) {
+int mp3Read(mp3DecodeData * data, OutputBuffer * cb, DecoderControl * dc, ReplayGainInfo ** replayGainInfo) {
 	int i;
 	int ret;
 	int skip;
@@ -593,7 +649,7 @@
 						data->outputBuffer,
                                                 data->elapsedTime,
                                                 data->bitRate/1000,
-						NULL);
+						(replayGainInfo != NULL) ? *replayGainInfo : NULL);
                                 if(ret == OUTPUT_BUFFER_DC_STOP) {
 					data->flush = 0;
                                         return DECODE_BREAK;
@@ -635,7 +691,7 @@
 
 	while(1) {
 		skip = 0;
-		while((ret = decodeNextFrameHeader(data, NULL))==DECODE_CONT &&
+		while((ret = decodeNextFrameHeader(data, NULL, replayGainInfo))==DECODE_CONT &&
 				!dc->stop && !dc->seek);
 		if(ret==DECODE_BREAK || dc->stop || dc->seek) break;
 		else if(ret==DECODE_SKIP) skip = 1;
@@ -661,8 +717,9 @@
 int mp3_decode(OutputBuffer * cb, DecoderControl * dc, InputStream * inStream) {
 	mp3DecodeData data;
 	MpdTag * tag = NULL;
-
-	if(openMp3FromInputStream(inStream, &data, dc, &tag) < 0) {
+	ReplayGainInfo * replayGainInfo = NULL;
+	
+	if(openMp3FromInputStream(inStream, &data, dc, &tag, &replayGainInfo) < 0) {
 		closeInputStream(inStream);
 		if(!dc->stop) {
                         ERROR("Input does not appear to be a mp3 bit stream.\n");
@@ -714,7 +771,7 @@
 
 	dc->state = DECODE_STATE_DECODE;
 
-	while(mp3Read(&data,cb,dc)!=DECODE_BREAK);
+	while(mp3Read(&data,cb,dc, &replayGainInfo)!=DECODE_BREAK);
 	/* send last little bit if not dc->stop */
 	if(!dc->stop && data.outputPtr!=data.outputBuffer && data.flush)  {
         	sendDataToOutputBuffer(cb, NULL, dc, 
@@ -722,9 +779,13 @@
                                 data.outputBuffer,
                                 data.outputPtr-data.outputBuffer,
                                 data.elapsedTime,data.bitRate/1000,
-				NULL);
+				replayGainInfo);
 	}
 
+	// if we have replaygain info, free it
+	if (replayGainInfo)
+		freeReplayGainInfo(replayGainInfo);
+
 	closeInputStream(inStream);
 
 	if(dc->seek && data.muteFrame == MUTEFRAME_SEEK) {
Index: src/libid3tag/tag.c
===================================================================
--- src/libid3tag/tag.c	(revision 3712)
+++ src/libid3tag/tag.c	(working copy)
@@ -247,6 +247,60 @@
   return 0;
 }
 
+/*
+ * NAME:	tag->findframe_user()
+ * DESCRIPTION:	find in a tag a user text frame with the given description
+ */
+ #include <stdio.h>
+ 
+id3_utf8_t *id3_tag_findframe_user(struct id3_tag const *tag,
+				    char const *descr)
+{
+  unsigned int len, i;
+  id3_utf8_t *utf8;
+  struct id3_frame const * frame;
+  id3_ucs4_t const * ucs4;
+  union id3_field const * field;
+  int nstrings;
+  int j, k;
+	
+  assert(tag);
+
+  len = strlen(descr);
+
+  // lookup by description
+  for (i = 0; i < tag->nframes; ++i) {
+    if (strncmp(tag->frames[i]->id, "TXXX", 4) == 0) {
+    	// user-defined frame, compare the description to
+    	// what we're looking for.
+		frame = tag->frames[i];
+
+		if (frame->nfields < 3) return NULL;
+
+		// field1 contains the description
+		field = &frame->fields[1];
+		if (field->type != 4) return NULL;
+
+		utf8 = id3_ucs4_utf8duplicate(field->string.ptr);
+
+		if (strncmp(utf8, descr, len) != 0) {
+			free(utf8);
+		}
+		else {
+			free(utf8);
+			// we got it! grab the value from field 2
+			field = &frame->fields[2];
+			if (field->type != 4) return NULL;
+
+			utf8 = id3_ucs4_utf8duplicate(field->string.ptr);
+			
+			return utf8; // user must free it
+		}
+    }
+  }
+  return NULL;
+}
+
 enum tagtype {
   TAGTYPE_NONE = 0,
   TAGTYPE_ID3V1,
Index: src/libid3tag/id3tag.h
===================================================================
--- src/libid3tag/id3tag.h	(revision 3712)
+++ src/libid3tag/id3tag.h	(working copy)
@@ -267,6 +267,9 @@
 int id3_tag_attachframe(struct id3_tag *, struct id3_frame *);
 int id3_tag_detachframe(struct id3_tag *, struct id3_frame *);
 
+id3_utf8_t *id3_tag_findframe_user(struct id3_tag const *tag,
+				    char const *descr);
+
 struct id3_frame *id3_tag_findframe(struct id3_tag const *,
 				    char const *, unsigned int);
 
