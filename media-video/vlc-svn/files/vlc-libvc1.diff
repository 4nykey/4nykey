--- configure.ac.orig	2005-09-01 16:14:54.000000000 +0200
+++ configure.ac	2005-09-01 16:17:31.000000000 +0200
@@ -2710,6 +2710,43 @@
   ])
 fi
 
+dnl  libvc1 decoder plugin
+dnl
+AC_ARG_ENABLE(libvc1,
+[  --enable-libvc1         VC-1 codec (default disabled)])
+if test "${enable_libvc1}" = "yes"; then
+if test -z "${with_libvc1_tree}"; then
+  AC_CHECK_HEADERS(vc1types.h, [
+    AC_CHECK_LIB(vc1, vc1DEC_DecoderInitialise, [
+    VLC_ADD_BUILTINS([libvc1])
+    VLC_ADD_LDFLAGS([libvc1],[-lvc1])
+    ],[
+      AC_MSG_ERROR([Could not find libvc1 on your system: you may get it from http://nanocrew.net/?p=129. Alternatively you can use --disable-libvc1.])
+    ])
+  ])
+else
+  AC_ARG_WITH(libvc1-tree,
+  [    --with-libvc1-tree=PATH libvc1 tree for static linking])
+  if test -n "${with_libvc1_tree}"
+  then
+    AC_MSG_CHECKING(for vc1dec.o in ${with_libvc1_tree})
+    real_libvc1_tree="`cd ${with_libvc1_tree} 2>/dev/null && pwd`"
+    if test -f "${real_libvc1_tree}/src/.libs/vc1dec.o"
+    then
+      VLC_ADD_BUILTINS([libvc1])
+      VLC_ADD_CPPFLAGS([libvc1],[-I${real_libvc1_tree}/src])
+      VLC_ADD_LDFLAGS([libvc1],[${real_libvc1_tree}/src/.libs/libvc1.a])
+      AC_MSG_RESULT(yes)
+    else
+      dnl  The given libvc1 tree wasn't built
+      AC_MSG_RESULT(no)
+      AC_MSG_ERROR([cannot find ${real_libvc1_tree}/src/.libs/vc1dec.o,
+                    make sure you compiled libvc1 in ${with_libvc1_tree}])
+    fi
+  fi
+fi
+fi
+
 dnl
 dnl  PNG decoder module
 dnl
diff -urN modules/codec.orig/libvc1.c modules/codec/libvc1.c
--- modules/codec.orig/libvc1.c	1970-01-01 01:00:00.000000000 +0100
+++ modules/codec/libvc1.c	2005-09-01 16:49:26.000000000 +0200
@@ -0,0 +1,223 @@
+/*****************************************************************************
+ * libvc1.c: VC-1 decoder module making use of libvc1.
+ *****************************************************************************
+ * Copyright (C) 2005 Jon Lech Johansen <jon@nanocrew.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#include <vlc/vlc.h>
+#include <vlc/decoder.h>
+
+#include <vc1types.h>
+#include <vc1dec.h>
+#include <vc1decbit.h>
+
+/*****************************************************************************
+ * decoder_sys_t : VC-1 decoder descriptor
+ *****************************************************************************/
+struct decoder_sys_t
+{
+    UWORD32 InstanceSize;
+    vc1DEC_sState *pState;
+    vc1DEC_sBitstream sBitstream;
+    vc1DEC_sDecoderConfiguration sConfig;
+};
+
+/*****************************************************************************
+ * Local prototypes
+ *****************************************************************************/
+static int  OpenDecoder  ( vlc_object_t * );
+static void CloseDecoder ( vlc_object_t * );
+
+static void *DecodeBlock ( decoder_t *, block_t ** );
+
+/*****************************************************************************
+ * Module descriptor
+ *****************************************************************************/
+vlc_module_begin();
+    set_description( _("VC-1 decoder module") );
+    set_capability( "decoder", 100 );
+    set_category( CAT_INPUT );
+    set_subcategory( SUBCAT_INPUT_VCODEC );
+    set_callbacks( OpenDecoder, CloseDecoder );
+    add_shortcut( "libvc1" );
+vlc_module_end();
+
+/*****************************************************************************
+ * OpenDecoder: probe the decoder and return score
+ *****************************************************************************/
+static int OpenDecoder( vlc_object_t *p_this )
+{
+    decoder_t *p_dec = (decoder_t*)p_this;
+    decoder_sys_t *p_sys;
+
+    if( p_dec->fmt_in.i_codec != VLC_FOURCC('W','M','V','3') )
+    {
+        return VLC_EGENERIC;
+    }
+
+    /* Allocate the memory needed to store the decoder's structure */
+    if( ( p_dec->p_sys = p_sys =
+          (decoder_sys_t *)malloc(sizeof(decoder_sys_t)) ) == NULL )
+    {
+        msg_Err( p_dec, "out of memory" );
+        return VLC_EGENERIC;
+    }
+
+    memset( p_sys, 0, sizeof(decoder_sys_t) );
+
+    p_sys->sConfig.eLevel = vc1_LevelUnknown;
+    p_sys->sConfig.MaxCodedWidth = p_dec->fmt_in.video.i_width;
+    p_sys->sConfig.MaxCodedHeight = p_dec->fmt_in.video.i_height;
+
+    if( p_dec->fmt_in.i_extra == 0 )
+    {
+        msg_Err( p_dec, "stream without extradata is not yet supported" );
+        free( (void *)p_sys );
+        return VLC_EGENERIC;
+    }
+
+    if( vc1DECBIT_InitialiseBitstream( &p_sys->sBitstream,
+                                       p_dec->fmt_in.p_extra,
+                                       p_dec->fmt_in.i_extra,
+                                       FALSE ) != vc1_ResultOK )
+    {
+        msg_Err( p_dec, "failed to initialize bitstream" );
+        free( (void *)p_sys );
+        return VLC_EGENERIC;
+    }
+
+    if( vc1DEC_DecoderRequirements( &p_sys->InstanceSize,
+                                    &p_sys->sConfig,
+                                    &p_sys->sBitstream ) != vc1_ResultOK )
+    {
+        msg_Err( p_dec, "failed to get decoder requirements" );
+        free( (void *)p_sys );
+        return VLC_EGENERIC;
+    }
+
+    p_sys->pState = (vc1DEC_sState *)malloc( p_sys->InstanceSize );
+    if( p_sys->pState == NULL )
+    {
+        msg_Err( p_dec, "out of memory" );
+        free( (void *)p_sys );
+        return VLC_EGENERIC;
+    }
+
+    if( vc1DEC_DecoderInitialise( p_sys->pState,
+                                  &p_sys->sConfig ) != vc1_ResultOK )
+    {
+        msg_Err( p_dec, "decoder init failed" );
+        free( (void *)p_sys->pState );
+        free( (void *)p_sys );
+        return VLC_EGENERIC;
+    }
+
+    if( vc1DEC_DecodeSequence( p_sys->pState,
+                               &p_sys->sBitstream ) != vc1_ResultOK )
+    {
+        msg_Err( p_dec, "decode sequence failed" );
+        free( (void *)p_sys->pState );
+        free( (void *)p_sys );
+        return VLC_EGENERIC;
+    }
+
+    /* Set output properties */
+    p_dec->fmt_out.i_cat = VIDEO_ES;
+    p_dec->fmt_out.video.i_width = p_sys->pState->sSeqParams.DisplayWidth;
+    p_dec->fmt_out.video.i_height = p_sys->pState->sSeqParams.DisplayHeight;
+    p_dec->fmt_out.video.i_aspect = p_dec->fmt_out.video.i_width *
+        VOUT_ASPECT_FACTOR / p_dec->fmt_out.video.i_height;
+    p_dec->fmt_out.i_codec = VLC_FOURCC('I','4','2','0');
+
+    /* Set callbacks */
+    p_dec->pf_decode_video = (picture_t *(*)(decoder_t *, block_t **))
+        DecodeBlock;
+    p_dec->pf_packetize    = (block_t *(*)(decoder_t *, block_t **))
+        DecodeBlock;
+
+    return VLC_SUCCESS;
+}
+
+/****************************************************************************
+ * DecodeBlock: the whole thing
+ ****************************************************************************/
+static void *DecodeBlock( decoder_t *p_dec, block_t **pp_block )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+    vc1_sPicture sPicture;
+    picture_t *p_pic;
+    block_t *p_block;
+    vc1_eResult res;
+
+    if( !pp_block || !*pp_block ) return NULL;
+    p_block = *pp_block;
+
+    if( ( p_pic = p_dec->pf_vout_buffer_new( p_dec ) ) == NULL )
+    {
+        msg_Err( p_dec, "new picture failed" );
+        return NULL;
+    }
+
+    //p_pic->date = mdate() + DEFAULT_PTS_DELAY;
+    p_pic->date = p_block->i_pts ? p_block->i_pts : p_block->i_dts;
+
+    if( vc1DECBIT_InitialiseBitstream( &p_sys->sBitstream,
+                                       p_block->p_buffer,
+                                       p_block->i_buffer,
+                                       FALSE ) != vc1_ResultOK )
+    {
+        msg_Err( p_dec, "failed to initialize bitstream" );
+        return NULL;
+    }
+
+    sPicture.sY.pData = p_pic->p[0].p_pixels;
+    sPicture.sY.Bpl = p_dec->fmt_out.video.i_width;
+    sPicture.sU.pData = p_pic->p[1].p_pixels;
+    sPicture.sU.Bpl = p_dec->fmt_out.video.i_width / 2;
+    sPicture.sV.pData = p_pic->p[2].p_pixels;
+    sPicture.sV.Bpl = p_dec->fmt_out.video.i_width / 2;
+
+    res = vc1DEC_DecodeFrame( p_sys->pState,
+                              &p_sys->sBitstream,
+                              &sPicture );
+
+    block_Release( p_block ); *pp_block = NULL;
+
+    if( res != vc1_ResultOK && res != vc1_ResultNoFrame )
+    {
+        msg_Err( p_dec, "failed to decode frame" );
+        return NULL;
+    }
+
+    return p_pic;
+}
+
+/*****************************************************************************
+ * CloseDecoder: VC-1 decoder destruction
+ *****************************************************************************/
+static void CloseDecoder( vlc_object_t *p_this )
+{
+    decoder_t *p_dec = (decoder_t *)p_this;
+    decoder_sys_t *p_sys = p_dec->p_sys;
+
+    free( (void *)p_sys->pState );
+
+    free( p_sys );
+}
diff -urN modules/codec.orig/Modules.am modules/codec/Modules.am
--- modules/codec.orig/Modules.am	2005-09-01 16:20:24.000000000 +0200
+++ modules/codec/Modules.am	2005-09-01 16:20:51.000000000 +0200
@@ -13,6 +13,7 @@
 SOURCES_adpcm = adpcm.c
 SOURCES_mpeg_audio = mpeg_audio.c
 SOURCES_libmpeg2 = libmpeg2.c
+SOURCES_libvc1 = libvc1.c
 SOURCES_rawvideo = rawvideo.c
 SOURCES_quicktime = quicktime.c
 SOURCES_subsdec = subsdec.c
