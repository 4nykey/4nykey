Index: libmpcodecs/vd_ffmpeg.c
===================================================================
--- libmpcodecs/vd_ffmpeg.c	(revision 26857)
+++ libmpcodecs/vd_ffmpeg.c	(working copy)
@@ -13,6 +13,7 @@
 #include "mpbswap.h"
 
 #include "vd_internal.h"
+#include "libvo/video_out.h"
 
 static vd_info_t info = {
 	"FFmpeg's libavcodec codec family",
@@ -147,6 +148,8 @@
         case IMGFMT_XVMC_IDCT_MPEG2:
         case IMGFMT_XVMC_MOCO_MPEG2:
             if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_IDCT) return CONTROL_TRUE;
+        case IMGFMT_XVMC_VLD_MPEG2:
+            if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_VLD) return CONTROL_TRUE;
 #endif
 	}
         return CONTROL_FALSE;
@@ -217,6 +220,9 @@
     vd_ffmpeg_ctx *ctx;
     AVCodec *lavc_codec;
     int lowres_w=0;
+#ifdef HAVE_XVMC
+    char *voname = 0;
+#endif
     int do_vis_debug= lavc_param_vismv || (lavc_param_debug&(FF_DEBUG_VIS_MB_TYPE|FF_DEBUG_VIS_QP));
 
     if(!avcodec_initialized){
@@ -252,11 +258,23 @@
 
 #ifdef HAVE_XVMC
 
+    // Try and get the name of the selected vo system
+    // so that if its _not_ xvmc we can fail gracefully
+    // and mplayer can fall back to a sw decoder
+    if (sh->video_out) {
+      vo_info_t *voinfo;
+      vo_functions_t * shvoc=sh->video_out;
+      if (shvoc) {
+        voinfo = shvoc->info;
+        if (voinfo) voname=voinfo->short_name;
+      }
+    }
 #ifdef CODEC_CAP_HWACCEL
-    if(lavc_codec->capabilities & CODEC_CAP_HWACCEL){
+    if((lavc_codec->capabilities & CODEC_CAP_HWACCEL) &&
 #else
-    if(lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC){
+    if((lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC) &&
 #endif /* CODEC_CAP_HWACCEL */
+        voname && !strcmp(voname,"xvmc") ) {
         mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCAcceleratedCodec);
         assert(ctx->do_dr1);//these are must to!
         assert(ctx->do_slices); //it is (vo_)ffmpeg bug if this fails
@@ -536,6 +554,7 @@
 #ifdef HAVE_XVMC
         case PIX_FMT_XVMC_MPEG2_MC:ctx->best_csp=IMGFMT_XVMC_MOCO_MPEG2;break;
         case PIX_FMT_XVMC_MPEG2_IDCT:ctx->best_csp=IMGFMT_XVMC_IDCT_MPEG2;break;
+        case PIX_FMT_XVMC_MPEG2_VLD:ctx->best_csp=IMGFMT_XVMC_VLD_MPEG2;break;
 #endif
 	default:
 	    ctx->best_csp=0;
@@ -920,7 +939,11 @@
         avctx->get_buffer= mc_get_buffer;
         avctx->release_buffer= mc_release_buffer;
         avctx->draw_horiz_band = mc_render_slice;
+        if (avctx->xvmc_acceleration != 4)
         mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCAcceleratedMPEG2);
+        else
+            mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCVLDAcceleratedMPEG2);
+
         assert(ctx->do_dr1);//these are must to!
         assert(ctx->do_slices); //it is (vo_)ffmpeg bug if this fails
         avctx->flags|= CODEC_FLAG_EMU_EDGE;//do i need that??!!
Index: libmpcodecs/img_format.c
===================================================================
--- libmpcodecs/img_format.c	(revision 26857)
+++ libmpcodecs/img_format.c	(working copy)
@@ -67,6 +67,7 @@
 	case IMGFMT_ZRMJPEGIB: return "Zoran MJPEG bottom field first";
 	case IMGFMT_XVMC_MOCO_MPEG2: return "MPEG1/2 Motion Compensation";
 	case IMGFMT_XVMC_IDCT_MPEG2: return "MPEG1/2 Motion Compensation and IDCT";
+	case IMGFMT_XVMC_VLD_MPEG2: return("MPEG1/2 Motion Compensation and VLD");
     }
     snprintf(unknown_format,20,"Unknown 0x%04x",format);
     return unknown_format;
Index: libmpcodecs/img_format.h
===================================================================
--- libmpcodecs/img_format.h	(revision 26857)
+++ libmpcodecs/img_format.h	(working copy)
@@ -106,6 +106,7 @@
 //these are chroma420
 #define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
 #define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
+#define IMGFMT_XVMC_VLD_MPEG2 (IMGFMT_XVMC|0x42)
 
 typedef struct {
     void* data;
Index: codec-cfg.c
===================================================================
--- codec-cfg.c	(revision 26857)
+++ codec-cfg.c	(working copy)
@@ -179,6 +179,7 @@
 		{"ZRMJPEGIT", IMGFMT_ZRMJPEGIT},
 		{"ZRMJPEGIB", IMGFMT_ZRMJPEGIB},
 
+		{"VLD_MPEG2",IMGFMT_XVMC_VLD_MPEG2},
 		{"IDCT_MPEG2",IMGFMT_XVMC_IDCT_MPEG2},
 		{"MOCO_MPEG2",IMGFMT_XVMC_MOCO_MPEG2},
 
Index: libvo/vo_xvmc.c
===================================================================
--- libvo/vo_xvmc.c	(revision 26857)
+++ libvo/vo_xvmc.c	(working copy)
@@ -23,6 +23,11 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+extern int has_xvmc_vld;
+#endif
+
 #include "x11_common.h"
 #include "xvmc_render.h"
 
@@ -45,6 +50,7 @@
 
 
 #define UNUSED(x) ((void)(x))
+extern unsigned int video_format; 
 
 #include "libavcodec/avcodec.h"
 #if LIBAVCODEC_BUILD < ((51<<16)+(40<<8)+2)
@@ -60,6 +66,8 @@
 static int xv_adaptor = -1; 
 static int bob_deinterlace;
 static int top_field_first;
+static int use_deint_one;
+static int use_tv_clip;
 
 static int image_width,image_height;
 static int image_format;
@@ -124,7 +132,7 @@
   "XVideo Motion Compensation",
   "xvmc",
   "Ivan Kalvachev <iive@users.sf.net>",
-  ""
+  "Ivor Hewitt <ivor@ivor.org> - VIA VLD support"
 };
 
 const LIBVO_EXTERN(xvmc);
@@ -197,7 +205,23 @@
 }
 //end of vo_xv shm/xvimage code
 
+int hasVLDAcceleration()
+{
+#ifdef HAVE_XVMC_VLD
+    return XVMC_VLD == (surface_info.mc_type & XVMC_VLD);
+#else
+    return 0;
+#endif
+}            
+
 static int xvmc_check_surface_format(uint32_t format, XvMCSurfaceInfo * surf_info){
+#ifdef HAVE_XVMC_VLD
+    if (format == IMGFMT_XVMC_VLD_MPEG2 ){
+        if( surf_info->mc_type != (XVMC_VLD|XVMC_MPEG_2) ) return -1;
+        if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
+        return 0;
+    }
+#endif
    if ( format == IMGFMT_XVMC_IDCT_MPEG2 ){ 
       if( surf_info->mc_type != (XVMC_IDCT|XVMC_MPEG_2) ) return -1;
       if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
@@ -366,6 +390,59 @@
    return VO_TRUE;
 }
 
+
+static int
+check_xvmc_vld()
+{
+   int              rez;
+   XvAdaptorInfo*   ai;
+   XvMCSurfaceInfo* surf_info;
+   int              max_adaptor;
+   int              max_surf;
+   int              i;
+   unsigned long    p;
+   int              s;
+
+   rez = XvQueryAdaptors(mDisplay, DefaultRootWindow(mDisplay),
+        &max_adaptor,&ai);
+   if (rez != Success)  return;
+
+   if (mp_msg_test(MSGT_VO, MSGL_DBG3))
+      printf("vo_xvmc: Querying %d adaptors for VLD\n", max_adaptor);
+
+   for (i = 0;  i < max_adaptor;  i++)
+   {
+      if (mp_msg_test(MSGT_VO,MSGL_DBG3))
+         printf("vo_xvmc: Quering adaptor #%d for VLD\n", i);
+      if (ai[i].type == 0)  continue;
+
+      // Probing every XV port
+      for (p = ai[i].base_id;  p < ai[i].base_id + ai[i].num_ports;  p++)
+      {
+         // Respect the users wish
+         if ((xv_port_request != 0) && (xv_port_request != p))  continue;
+         if (mp_msg_test(MSGT_VO,MSGL_DBG3))
+            printf("vo_xvmc: Probing port #%ld for VLD\n", p);
+         surf_info = XvMCListSurfaceTypes(mDisplay, p, &max_surf);
+         if (surf_info == NULL || max_surf == 0)  continue;
+
+         // We have XvMC list!
+         for(s = 0;  s < max_surf;  s++)
+         {
+            // We have match!
+            if (XVMC_VLD == (surf_info[s].mc_type & XVMC_VLD))
+                has_xvmc_vld = 1;
+         }
+         XFree(surf_info);
+      }
+   }
+   XvFreeAdaptorInfo(ai);
+
+   if (mp_msg_test(MSGT_VO,MSGL_DBG3) && has_xvmc_vld)
+      printf("vo_xvmc: Found VLD support in XvMC\n");
+}
+
+
 static int preinit(const char *arg){
 int xv_version,xv_release,xv_request_base,xv_event_base,xv_error_base;
 int mc_eventBase,mc_errorBase;
@@ -383,9 +460,16 @@
   {  "sleep",     OPT_ARG_BOOL, &use_sleep,       NULL },
   {  "queue",     OPT_ARG_BOOL, &use_queue,       NULL },
   {  "bobdeint",  OPT_ARG_BOOL, &bob_deinterlace, NULL },
+  {  "onedeint",  OPT_ARG_BOOL, &use_deint_one,   NULL },
+  {  "tv-clip",   OPT_ARG_BOOL, &use_tv_clip,     NULL },
   {  NULL }
 };
 
+   // If the video is not MPEG1 or MPEG2, we can't decode it, so
+   // fail cleanly to allow mplayer to fallback to another vo system
+   if (video_format != 0x10000001 && video_format != 0x10000002) return -1;
+
+
    //Obtain display handler
    if (!vo_init()) return -1;//vo_xv
 
@@ -421,6 +505,8 @@
    use_sleep = 0;
    use_queue = 0;
    bob_deinterlace = 0;
+   use_deint_one = 0;
+   use_tv_clip = 0;
 
    /* parse suboptions */
    if ( subopt_parse( arg, subopts ) != 0 )
@@ -430,6 +516,9 @@
 
    xv_setup_colorkeyhandling( ck_method_arg.str, ck_src_arg.str );
 
+   // Check whether XvMC supports VLD
+   check_xvmc_vld();
+
    return 0;
 }
 
@@ -511,6 +600,8 @@
    if(surface_info.chroma_format == XVMC_CHROMA_FORMAT_444)
       blocks_per_macroblock = 12;
 
+if (!hasVLDAcceleration())
+{
    rez = XvMCCreateBlocks(mDisplay,&ctx,numblocks*blocks_per_macroblock,&data_blocks);
    if( rez != Success ){
       XvMCDestroyContext(mDisplay,&ctx);
@@ -526,6 +617,8 @@
    }
    printf("vo_xvmc: mv_blocks allocated\n");
 
+}
+
    if(surface_render==NULL)
       surface_render=malloc(MAX_SURFACES*sizeof(xvmc_render_state_t));//easy mem debug
    memset(surface_render,0,MAX_SURFACES*sizeof(xvmc_render_state_t));
@@ -544,6 +637,11 @@
       surface_render[i].chroma_format = surface_info.chroma_format;
       surface_render[i].unsigned_intra = (surface_info.flags & XVMC_INTRA_UNSIGNED) == XVMC_INTRA_UNSIGNED;
       surface_render[i].p_surface = &surface_array[i];
+
+      surface_render[i].state = 0;
+      surface_render[i].disp = mDisplay;
+      surface_render[i].ctx = &ctx;
+
       if( mp_msg_test(MSGT_VO,MSGL_DBG4) )
           printf("vo_xvmc: surface[%d] = %p .rndr=%p\n",i,&surface_array[i], &surface_render[i]);
    }
@@ -999,6 +1097,8 @@
 int rez;
 int clipX,clipY,clipW,clipH;
 int i;
+ int srcY=0, srcH=image_height;
+ int fieldnobob;
 
    if(p_render_surface == NULL)
       return;
@@ -1008,22 +1108,38 @@
    clipW = vo_dwidth+vo_panscan_x;
    clipH = vo_dheight+vo_panscan_y;
    
+   if (use_tv_clip) {
+     /*
+      * Clip top few lines off to get rid of annoying flicker
+      * when using bob de-interlacing on TV sourced video.
+      */
+     srcY+=4;
+     srcH-=4;
+   }
+   
    if(draw_ck)
       vo_xv_draw_colorkey(clipX,clipY,clipW,clipH);
 
    if(benchmark)
       return;
 
+   fieldnobob = XVMC_FRAME_PICTURE;
+
+   if (use_deint_one) 
+     fieldnobob = (top_field_first) ? XVMC_TOP_FIELD : XVMC_BOTTOM_FIELD;
+
    for (i = 1; i <= bob_deinterlace + 1; i++) {
-   int field = top_field_first ? i : i ^ 3;
+     int field = top_field_first ? i : i ^ XVMC_FRAME_PICTURE;
    rez = XvMCPutSurface(mDisplay, p_render_surface->p_surface, 
                         vo_window,
-                        0, 0, image_width, image_height,
+			  0, srcY, image_width, srcH,
                         clipX, clipY, clipW, clipH,
-                        bob_deinterlace ? field : 3);
-                        //p_render_surface_to_show->display_flags);
+			  bob_deinterlace ? field : fieldnobob);
+     if (i == 1 && bob_deinterlace) {
+       usleep(10*1000);
+     }
    if(rez != Success){
-      printf("vo_xvmc: PutSurface failer, critical error %d!\n",rez);
+       printf("vo_xvmc: PutSurface failure, critical error %d!\n",rez);
       assert(0);
    }
    }
@@ -1115,9 +1231,11 @@
 
    if( number_of_surfaces ){
 
+      if (!hasVLDAcceleration())
+      {
       XvMCDestroyMacroBlocks(mDisplay,&mv_blocks);
       XvMCDestroyBlocks(mDisplay,&data_blocks);
-
+      }
       for(i=0; i<number_of_surfaces; i++)
       {
          XvMCHideSurface(mDisplay,&surface_array[i]);//it doesn't hurt, I hope
@@ -1195,6 +1313,17 @@
    assert( rndr != NULL );
    assert( rndr->magic == MP_XVMC_RENDER_MAGIC );
 
+   if (hasVLDAcceleration())
+   {
+        rez = XvMCPutSlice2(mDisplay,&ctx,(char*)rndr->slice_data,
+                            rndr->slice_datalen,
+                            rndr->slice_code);
+        if (rez)
+           printf("vo_xxmc::slice Error %d\n",rez);
+
+   }
+   else
+   {
    rez = XvMCRenderSurface(mDisplay,&ctx,rndr->picture_structure,
              		   rndr->p_surface,
                            rndr->p_past_surface,
@@ -1206,7 +1335,7 @@
    if(rez != Success)
    {
    int i;
-      printf("vo_xvmc::slice: RenderSirface returned %d\n",rez);
+      printf("vo_xvmc::slice: RenderSurface returned %d\n",rez);
 
       printf("vo_xvmc::slice: pict=%d,flags=%x,start_blocks=%d,num_blocks=%d\n",
              rndr->picture_structure,rndr->flags,rndr->start_mv_blocks_num,
@@ -1234,6 +1363,7 @@
    rez = XvMCFlushSurface(mDisplay, rndr->p_surface);
    assert(rez==Success);
 
+}
 //   rndr->start_mv_blocks_num += rndr->filled_mv_blocks_num;
    rndr->start_mv_blocks_num = 0;
    rndr->filled_mv_blocks_num = 0;
@@ -1343,8 +1473,16 @@
 
 // these are shared!! so watch out
 // do call RenderSurface before overwriting
+if (!hasVLDAcceleration())
+{
    mpi->planes[0] = (char*)data_blocks.blocks;   
    mpi->planes[1] = (char*)mv_blocks.macro_blocks;
+}
+else
+{
+   mpi->planes[0] = 1;
+   mpi->planes[1] = 0;
+}
    mpi->priv =
    mpi->planes[2] = (char*)rndr;
 
Index: configure
===================================================================
--- configure	(revision 26857)
+++ configure	(working copy)
@@ -524,6 +524,7 @@
 _dga2=auto
 _xv=auto
 _xvmc=no  #auto when complete
+_xvmc_vld=auto
 _sdl=auto
 _directx=auto
 _win32waveout=auto
@@ -3888,7 +3889,7 @@
   _novomodules="x11 $_novomodules"
   _res_comment="check if the dev(el) packages are installed"
   # disable stuff that depends on X
-  _xv=no ; _xvmc=no ; _xinerama=no ; _vm=no ; _xf86keysym=no
+  _xv=no ; _xvmc=no ; _xvmc_vld=no ; _xinerama=no ; _vm=no ; _xf86keysym=no
 fi
 echores "$_x11"
 
@@ -4001,6 +4002,31 @@
 echores "$_xvmc"
 
 
+echocheck "XvMC VLD"
+if test "$_xvmc" = yes ; then
+  _xvmc_vld=no
+  cat > $TMPC <<EOF
+#include <X11/Xlib.h>
+#include <X11/extensions/Xvlib.h>
+#include <X11/extensions/XvMClib.h>
+#include <X11/extensions/vldXvMC.h>
+int main(void) { 
+  (void) XvMCQueryExtension(0,0,0);
+  (void) XvMCCreateContext(0,0,0,0,0,0,0);
+  return 0; }
+EOF
+  cc_check -lXvMC -l$_xvmclib && _xvmc_vld=yes
+  if test "$_xvmc_vld" = yes ; then
+    _def_xvmc_vld='#define HAVE_XVMC_VLD 1'
+    _libs_mencoder="$_libs_mencoder -l$_xvmclib"
+  else
+    _def_xvmc_vld='#undef HAVE_XVMC_VLD'
+    _libavdecoders=`echo $_libavdecoders | sed -e s/MPEG_XVMC_VLD_DECODER// `
+  fi
+fi
+echores "$_xvmc_vld"
+
+
 echocheck "Xinerama"
 if test "$_xinerama" = auto ; then
   cat > $TMPC <<EOF
@@ -8495,6 +8521,7 @@
 $_def_x11
 $_def_xv
 $_def_xvmc
+$_def_xvmc_vld
 $_def_vm
 $_def_xf86keysym
 $_def_xinerama
Index: mplayer.c
===================================================================
--- mplayer.c	(revision 26857)
+++ mplayer.c	(working copy)
@@ -87,6 +87,8 @@
 int quiet=0;
 int enable_mouse_movements=0;
 
+unsigned int video_format=0;
+
 #ifdef WIN32
 char * proc_priority=NULL;
 #endif
@@ -2148,10 +2150,16 @@
     //shouldn't we set dvideo->id=-2 when we fail?
     vo_config_count=0;
     //if((mpctx->video_out->preinit(vo_subdevice))!=0){
+
+    // let the video driver know what format the video is in so it can
+    // reject it if it wants - lets vo_xvmc fail if ffmpeg12mc codec not used
+    video_format=sh_video->format; 
+
     if(!(mpctx->video_out=init_best_video_out(video_driver_list))){
       mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_ErrorInitializingVODevice);
       goto err_out;
     }
+    sh_video->video_out=mpctx->video_out;
     initialized_flags|=INITIALIZED_VO;
   }
 
Index: help/help_mp-en.h
===================================================================
--- help/help_mp-en.h	(revision 26857)
+++ help/help_mp-en.h	(working copy)
@@ -1659,6 +1659,7 @@
 #define MSGTR_MPCODECS_DRIFailure "[VD_FFMPEG] DRI failure.\n"
 #define MSGTR_MPCODECS_CouldntAllocateImageForCodec "[VD_FFMPEG] Couldn't allocate image for codec.\n"
 #define MSGTR_MPCODECS_XVMCAcceleratedMPEG2 "[VD_FFMPEG] XVMC-accelerated MPEG-2.\n"
+#define MSGTR_MPCODECS_XVMCVLDAcceleratedMPEG2 "[VD_FFMPEG] XVMC-VLD-accelerated MPEG-2.\n"
 #define MSGTR_MPCODECS_TryingPixfmt "[VD_FFMPEG] Trying pixfmt=%d.\n"
 #define MSGTR_MPCODECS_McGetBufferShouldWorkOnlyWithXVMC "[VD_FFMPEG] The mc_get_buffer should work only with XVMC acceleration!!"
 #define MSGTR_MPCODECS_UnexpectedInitVoError "[VD_FFMPEG] Unexpected init_vo error.\n"
Index: xvmc_render.h
===================================================================
--- xvmc_render.h	(revision 26857)
+++ xvmc_render.h	(working copy)
@@ -8,6 +8,9 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
 
 //the surface should be shown, video driver manipulates this
 #define MP_XVMC_STATE_DISPLAY_PENDING 1
@@ -30,6 +33,15 @@
   int idct;//Do we use IDCT acceleration?
   int chroma_format;//420,422,444
   int unsigned_intra;//+-128 for intra pictures after clip
+#ifdef HAVE_XVMC_VLD
+  // These are for the XVMC VLD slice interface
+  int pict_type; //this is for skipping frames
+  int slice_code; 
+  int slice_datalen;
+  unsigned char *slice_data;
+  Display *disp;
+  XvMCContext *ctx;
+#endif
   XvMCSurface* p_surface;//pointer to rendered surface, never changed
 
 //these are changed by decoder
Index: libmpdemux/stheader.h
===================================================================
--- libmpdemux/stheader.h	(revision 26857)
+++ libmpdemux/stheader.h	(working copy)
@@ -81,6 +81,7 @@
   int disp_w,disp_h;      // display size (filled by fileformat parser)
   // output driver/filters: (set by libmpcodecs core)
   unsigned int outfmtidx;
+  void* video_out;        // the video_out handle, used for this video stream
   struct vf_instance_s *vfilter;          // the video filter chain, used for this video stream
   int vf_initialized;
 #ifdef DYNAMIC_PLUGINS
Index: etc/codecs.conf
===================================================================
--- etc/codecs.conf	(revision 26857)
+++ etc/codecs.conf	(working copy)
@@ -152,6 +152,7 @@
   fourcc MMES,mmes   ; matrox mpeg2 in avi
   driver ffmpeg
   dll "mpegvideo_xvmc"
+  out VLD_MPEG2
   out IDCT_MPEG2
   out MOCO_MPEG2
 
Index: mencoder.c
===================================================================
--- mencoder.c	(revision 26857)
+++ mencoder.c	(working copy)
@@ -796,6 +796,7 @@
 mux_v->bih=NULL;
 }
 sh_video->codec=NULL;
+sh_video->video_out=NULL;
 sh_video->vfilter=NULL; // fixme!
 
 switch(mux_v->codec){
Index: libavcodec/xvmcvideo.c
===================================================================
--- libavcodec/xvmcvideo.c	(revision 13244)
+++ libavcodec/xvmcvideo.c	(working copy)
@@ -66,11 +66,68 @@
     }
 }
 
+#ifdef HAVE_XVMC_VLD
+static XvMCSurface* findPastSurface(MpegEncContext *s,
+                                    xvmc_render_state_t *render)
+{
+    Picture *lastp = s->last_picture_ptr;
+    xvmc_render_state_t *last = NULL;
+
+    if (NULL!=lastp) {
+        last = (xvmc_render_state_t*)(lastp->data[2]);
+        if (FF_B_TYPE==last->pict_type)
+            av_log(s->avctx,AV_LOG_DEBUG, "Past frame is a B frame in findPastSurface, this is bad.\n");
+        //assert(FF_B_TYPE!=last->pict_type);
+    }
+
+    if (NULL==last)
+        if (!s->first_field)
+            last = render; // predict second field from the first
+        else
+            return 0;
+
+    if (last->magic != MP_XVMC_RENDER_MAGIC)
+        return 0;
+
+    return (last->state & MP_XVMC_STATE_PREDICTION) ? last->p_surface : 0;
+}
+
+static XvMCSurface* findFutureSurface(MpegEncContext *s)
+{
+    Picture *nextp = s->next_picture_ptr;
+    xvmc_render_state_t *next = NULL;
+
+    if (NULL!=nextp) {
+        next = (xvmc_render_state_t*)(nextp->data[2]);
+        if (FF_B_TYPE==next->pict_type)
+            av_log(s->avctx,AV_LOG_DEBUG, "Next frame is a B frame in findFutureSurface, thisis bad.\n");
+        //assert(FF_B_TYPE!=next->pict_type);
+    }
+
+    assert(NULL!=next);
+
+    if (next->magic != MP_XVMC_RENDER_MAGIC)
+        return 0;
+
+    return (next->state & MP_XVMC_STATE_PREDICTION) ? next->p_surface : 0;
+}
+#endif //HAVE_XVMC_VLD
+
 //These functions should be called on every new field and/or frame.
 //They should be safe if they are called a few times for the same field!
 int XVMC_field_start(MpegEncContext*s, AVCodecContext *avctx){
 xvmc_render_state_t * render,* last, * next;
 
+#ifdef HAVE_XVMC_VLD
+    XvMCMpegControl     binfo;
+    XvMCQMatrix         qmatrix;
+    int                 i;
+    Status              status;
+
+    memset(&binfo, 0, sizeof(binfo));
+    memset(&qmatrix, 0, sizeof(qmatrix));
+#endif
+
     assert(avctx != NULL);
 
     render = (xvmc_render_state_t*)s->current_picture.data[2];
@@ -81,13 +138,54 @@
     render->picture_structure = s->picture_structure;
     render->flags = (s->first_field)? 0: XVMC_SECOND_FIELD;
 
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        if (render->picture_structure == PICT_FRAME)
+            render->flags |= XVMC_FRAME_PICTURE;
+        else if (render->picture_structure == PICT_TOP_FIELD)
+            render->flags |= XVMC_TOP_FIELD;
+        else if (render->picture_structure == PICT_BOTTOM_FIELD)
+            render->flags |= XVMC_BOTTOM_FIELD;
+    }
+    else
+#endif
+    {
 //make sure that all data is drawn by XVMC_end_frame
     assert(render->filled_mv_blocks_num==0);
+    }
 
     render->p_future_surface = NULL;
     render->p_past_surface = NULL;
 
+    render->pict_type = s->pict_type; // for later frame dropping use
+
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+{
     switch(s->pict_type){
+        case  FF_I_TYPE:
+            break;
+        case  FF_B_TYPE:
+            render->p_past_surface = findPastSurface(s, render);
+            render->p_future_surface = findFutureSurface(s);
+            if (!render->p_past_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding B frame and past frame is null!");
+            else if (!render->p_future_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding B frame and future frame is null!");
+            break;
+            
+        case  FF_P_TYPE:
+            render->p_past_surface = findPastSurface(s, render);
+            render->p_future_surface = render->p_surface;
+            if (!render->p_past_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding P frame and past frame is null!");
+            break;
+    }
+} else
+#endif
+{
+    switch(s->pict_type){
         case  FF_I_TYPE:
             return 0;// no prediction from other frames
         case  FF_B_TYPE:
@@ -107,7 +205,95 @@
             render->p_past_surface = last->p_surface;
             return 0;
     }
+}
 
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        for (i = 0; i < 64; i++){
+        qmatrix.intra_quantiser_matrix[i] = s->intra_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.non_intra_quantiser_matrix[i] = s->inter_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.chroma_intra_quantiser_matrix[i] = s->chroma_intra_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.chroma_non_intra_quantiser_matrix[i] = s->chroma_inter_matrix[s->dsp.idct_permutation[i]];
+        }
+
+    qmatrix.load_intra_quantiser_matrix = 1;
+    qmatrix.load_non_intra_quantiser_matrix = 1;
+    qmatrix.load_chroma_intra_quantiser_matrix = 1;
+    qmatrix.load_chroma_non_intra_quantiser_matrix = 1;
+
+
+    binfo.flags = 0;
+    if (s->alternate_scan)
+        binfo.flags |= XVMC_ALTERNATE_SCAN;
+    if (s->top_field_first)
+        binfo.flags |= XVMC_TOP_FIELD_FIRST;
+    if (s->frame_pred_frame_dct)
+        binfo.flags |= XVMC_PRED_DCT_FRAME;
+    else
+        binfo.flags |= XVMC_PRED_DCT_FIELD;
+
+    if (s->intra_vlc_format)
+        binfo.flags |= XVMC_INTRA_VLC_FORMAT;
+    if (!s->first_field && !s->progressive_sequence)
+        binfo.flags |= XVMC_SECOND_FIELD;
+    if (s->q_scale_type)
+        binfo.flags |= XVMC_Q_SCALE_TYPE;
+    if (s->concealment_motion_vectors)
+        binfo.flags |= XVMC_CONCEALMENT_MOTION_VECTORS;
+    if (s->progressive_sequence)
+        binfo.flags |= XVMC_PROGRESSIVE_SEQUENCE;
+
+    binfo.picture_structure = s->picture_structure;
+    switch (s->pict_type)
+    {
+    case FF_I_TYPE:    binfo.picture_coding_type = XVMC_I_PICTURE;     break;
+    case FF_P_TYPE:    binfo.picture_coding_type = XVMC_P_PICTURE;     break;
+    case FF_B_TYPE:    binfo.picture_coding_type = XVMC_B_PICTURE;     break;
+    default:    av_log(avctx, AV_LOG_ERROR, "%s: Unknown picture coding type: %d\n", __FUNCTION__, s->pict_type);
+    }
+
+    binfo.intra_dc_precision = s->intra_dc_precision;;
+
+    if (s->codec_id == CODEC_ID_MPEG2VIDEO)
+        binfo.mpeg_coding = 2;
+    else
+        binfo.mpeg_coding = 1;
+
+    s->mb_width = (s->width + 15) / 16;
+    s->mb_height = (s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence) ?
+        2 * ((s->height + 31) / 32) : (s->height + 15) / 16;
+
+    if (s->codec_id == CODEC_ID_MPEG2VIDEO)
+{
+    binfo.FVMV_range = (s->mpeg_f_code[0][1] - 1);
+    binfo.FHMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.BVMV_range = (s->mpeg_f_code[1][1] - 1);
+    binfo.BHMV_range = (s->mpeg_f_code[1][0] - 1);
+}
+else
+{
+    binfo.FVMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.FHMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.BVMV_range = (s->mpeg_f_code[1][1] - 1);
+    binfo.BHMV_range = (s->mpeg_f_code[1][1] - 1);
+}
+
+    status = XvMCLoadQMatrix(render->disp, render->ctx, &qmatrix);
+    if (status)
+        av_log(avctx,AV_LOG_ERROR, "XvMCLoadQMatrix: Error: %d\n", status);
+
+    status = XvMCBeginSurface(render->disp, render->ctx, render->p_surface,
+                              render->p_past_surface, render->p_future_surface,
+                              &binfo);
+    if (status)
+        av_log(avctx,AV_LOG_ERROR, "XvMCBeginSurface: Error: %d\n", status);
+
+    if (!status)
+        return 0;
+    }
+#endif
+
 return -1;
 }
 
@@ -116,11 +302,23 @@
     render = (xvmc_render_state_t*)s->current_picture.data[2];
     assert(render != NULL);
 
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        XvMCFlushSurface(render->disp, render->p_surface);
+        XvMCSyncSurface(render->disp, render->p_surface);
+
+    	s->error_count = 0;
+    }
+    else
+#endif
+    {
     if(render->filled_mv_blocks_num > 0){
 //        printf("xvmcvideo.c: rendering %d left blocks after last slice!!!\n",render->filled_mv_blocks_num );
         ff_draw_horiz_band(s,0,0);
     }
 }
+}
 
 void XVMC_decode_mb(MpegEncContext *s){
 XvMCMacroBlock * mv_block;
@@ -308,3 +506,49 @@
 // DumpMBlockInfo(mv_block);
 
 }
+
+#ifdef HAVE_XVMC_VLD
+static int length_to_next_start(uint8_t* pbuf_ptr, int buf_size)
+{
+    uint8_t*    buf_ptr;
+    unsigned int    state = 0xFFFFFFFF, v;
+
+    buf_ptr = pbuf_ptr;
+    while (buf_ptr < pbuf_ptr + buf_size)
+    {
+        v = *buf_ptr++;
+        if (state == 0x000001) {
+            return buf_ptr - pbuf_ptr - 4;
+        }
+        state = ((state << 8) | v) & 0xffffff;
+    }
+    return -1;
+}
+
+#define SLICE_MIN_START_CODE   0x00000101
+#define SLICE_MAX_START_CODE   0x000001af
+
+void XVMC_decode_slice(MpegEncContext *s, int mb_y, uint8_t* buffer, int buf_size)
+{
+    int slicelen = length_to_next_start(buffer, buf_size);
+    xvmc_render_state_t*    render;
+
+    if (slicelen < 0)
+    {
+        if ((mb_y == s->mb_height - 1) || 
+            (!s->progressive_sequence && mb_y == (s->mb_height >> 1) -1) ||
+	    (s->codec_id != CODEC_ID_MPEG2VIDEO))
+            slicelen = buf_size;
+        else
+            return;
+    }
+
+    render = (xvmc_render_state_t*)s->current_picture.data[2];
+    render->slice_code = SLICE_MIN_START_CODE + mb_y;
+    render->slice_data = buffer;
+    render->slice_datalen = slicelen;
+
+    ff_draw_horiz_band(s, 0, 0);
+}
+
+#endif
Index: libavcodec/xvmc_render.h
===================================================================
--- libavcodec/xvmc_render.h	(revision 13244)
+++ libavcodec/xvmc_render.h	(working copy)
@@ -28,6 +28,9 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
 
 //the surface should be shown, video driver manipulates this
 #define MP_XVMC_STATE_DISPLAY_PENDING 1
@@ -50,6 +53,15 @@
   int idct;//Do we use IDCT acceleration?
   int chroma_format;//420,422,444
   int unsigned_intra;//+-128 for intra pictures after clip
+#ifdef HAVE_XVMC_VLD
+  // These are for the XVMC VLD slice interface
+  int pict_type; //this is for skipping frames
+  int slice_code; 
+  int slice_datalen;
+  unsigned char *slice_data;
+  Display *disp;
+  XvMCContext *ctx;
+#endif
   XvMCSurface* p_surface;//pointer to rendered surface, never changed
 
 //these are changed by decoder
Index: libavcodec/mpeg12.c
===================================================================
--- libavcodec/mpeg12.c	(revision 13244)
+++ libavcodec/mpeg12.c	(working copy)
@@ -70,6 +70,13 @@
 extern void XVMC_pack_pblocks(MpegEncContext *s,int cbp);
 extern void XVMC_init_block(MpegEncContext *s);//set s->block
 
+
+#ifdef HAVE_XVMC_VLD
+extern int XVMC_decode_slice(MpegEncContext *s, int start_code,
+                                 uint8_t *buffer, int buf_size);
+int has_xvmc_vld = 0;
+#endif
+
 static const enum PixelFormat pixfmt_yuv_420[]= {PIX_FMT_YUV420P,PIX_FMT_NONE};
 static const enum PixelFormat pixfmt_yuv_422[]= {PIX_FMT_YUV422P,PIX_FMT_NONE};
 static const enum PixelFormat pixfmt_yuv_444[]= {PIX_FMT_YUV444P,PIX_FMT_NONE};
@@ -77,6 +84,11 @@
                                            PIX_FMT_XVMC_MPEG2_IDCT,
                                            PIX_FMT_XVMC_MPEG2_MC,
                                            PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_xvmc_vld_mpg2_420[] = {
+                                           PIX_FMT_XVMC_MPEG2_VLD,
+                                           PIX_FMT_XVMC_MPEG2_IDCT,
+                                           PIX_FMT_XVMC_MPEG2_MC,
+                                           -1};
 
 uint8_t ff_mpeg12_static_rl_table_store[2][2][2*MAX_RUN + MAX_LEVEL + 3];
 
@@ -1313,6 +1325,9 @@
         }//mpeg2
 
         if(avctx->xvmc_acceleration){
+            if (has_xvmc_vld)
+                avctx->pix_fmt = avctx->get_format(avctx,pixfmt_xvmc_vld_mpg2_420);
+            else
             avctx->pix_fmt = avctx->get_format(avctx,pixfmt_xvmc_mpg2_420);
         }else{
             if(s->chroma_format <  2){
@@ -1682,6 +1697,16 @@
         return -1;
     }
 
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4){
+        int used = XVMC_decode_slice(s, mb_y, *buf, buf_size);
+        if (used < 0)
+            return DECODE_SLICE_ERROR;
+        *buf += used - 1;
+        return DECODE_SLICE_OK;
+    }
+#endif
+
     init_get_bits(&s->gb, *buf, buf_size*8);
 
     ff_mpeg1_clean_buffers(s);
@@ -2080,6 +2105,9 @@
     s->low_delay= 1;
 
     if(avctx->xvmc_acceleration){
+        if (has_xvmc_vld)
+            avctx->pix_fmt = avctx->get_format(avctx,pixfmt_xvmc_vld_mpg2_420);
+        else
         avctx->pix_fmt = avctx->get_format(avctx,pixfmt_xvmc_mpg2_420);
     }else{
         avctx->pix_fmt = avctx->get_format(avctx,pixfmt_yuv_420);
@@ -2510,6 +2538,43 @@
 
 #endif
 
+#ifdef HAVE_XVMC_VLD
+static int mpeg_xxmc_decode_init(AVCodecContext *avctx){
+    Mpeg1Context *s;
+    if (!has_xvmc_vld)
+        return mpeg_mc_decode_init(avctx);
+    if( avctx->thread_count > 1)
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_CODED_ORDER) )
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD) )
+        dprintf("mpeg12.c: XVMC_VLD decoder will work better if SLICE_FLAG_ALLOW_FIELD is set\n");
+
+    mpeg_decode_init(avctx);
+    s = avctx->priv_data;
+
+    avctx->pix_fmt = PIX_FMT_XVMC_MPEG2_VLD;
+    avctx->xvmc_acceleration = 4;
+
+    return 0;
+}
+
+AVCodec mpeg_xvmc_vld_decoder = {
+    "mpegvideo_xvmc",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_MPEG2VIDEO_XVMC,
+    sizeof(Mpeg1Context),
+    mpeg_xxmc_decode_init,
+    NULL,
+    mpeg_decode_end,
+    mpeg_decode_frame,
+    CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED| CODEC_CAP_HWACCEL,
+    .flush= ff_mpeg_flush,
+};
+
+#endif
+
+
 /* this is ugly i know, but the alternative is too make
    hundreds of vars global and prefix them with ff_mpeg1_
    which is far uglier. */
Index: libavcodec/allcodecs.c
===================================================================
--- libavcodec/allcodecs.c	(revision 13244)
+++ libavcodec/allcodecs.c	(working copy)
@@ -109,6 +109,7 @@
     REGISTER_DECODER (MJPEGB, mjpegb);
     REGISTER_DECODER (MMVIDEO, mmvideo);
     REGISTER_DECODER (MOTIONPIXELS, motionpixels);
+    REGISTER_DECODER (MPEG_XVMC_VLD, mpeg_xvmc_vld);
     REGISTER_DECODER (MPEG_XVMC, mpeg_xvmc);
     REGISTER_ENCDEC  (MPEG1VIDEO, mpeg1video);
     REGISTER_ENCDEC  (MPEG2VIDEO, mpeg2video);
Index: libavutil/avutil.h
===================================================================
--- libavutil/avutil.h	(revision 13244)
+++ libavutil/avutil.h	(working copy)
@@ -95,6 +95,7 @@
     PIX_FMT_YUVJ444P,  ///< Planar YUV 4:4:4, 24bpp, full scale (jpeg)
     PIX_FMT_XVMC_MPEG2_MC,///< XVideo Motion Acceleration via common packet passing(xvmc_render.h)
     PIX_FMT_XVMC_MPEG2_IDCT,
+    PIX_FMT_XVMC_MPEG2_VLD,
     PIX_FMT_UYVY422,   ///< Packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
     PIX_FMT_UYYVYY411, ///< Packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
     PIX_FMT_BGR32,     ///< Packed RGB 8:8:8, 32bpp, (msb)8A 8B 8G 8R(lsb), in cpu endianness
