Index: ffmpeg.c
===================================================================
--- ffmpeg.c	(revision 5969)
+++ ffmpeg.c	(working copy)
@@ -1346,13 +1346,11 @@
                             ret = 0;
                             /* encode any samples remaining in fifo */
                             if(fifo_bytes > 0 && enc->codec->capabilities & CODEC_CAP_SMALL_LAST_FRAME) {
-                                int fs_tmp = enc->frame_size;
                                 enc->frame_size = fifo_bytes / (2 * enc->channels);
                                 if(fifo_read(&ost->fifo, (uint8_t *)samples, fifo_bytes,
                                         &ost->fifo.rptr) == 0) {
                                     ret = avcodec_encode_audio(enc, bit_buffer, bit_buffer_size, samples);
                                 }
-                                enc->frame_size = fs_tmp;
                             }
                             if(ret <= 0) {
                                 ret = avcodec_encode_audio(enc, bit_buffer, bit_buffer_size, NULL);
Index: libavcodec/avcodec.h
===================================================================
--- libavcodec/avcodec.h	(revision 5969)
+++ libavcodec/avcodec.h	(working copy)
@@ -2022,6 +2022,12 @@
      * - decoding: unused.
      */
     int max_partition_order;
+
+    /**
+     * - encoding: set by lavc.
+     * - decoding: unused.
+     */
+    uint8_t checksum[32];
 } AVCodecContext;
 
 /**
Index: libavcodec/flacenc.c
===================================================================
--- libavcodec/flacenc.c	(revision 5969)
+++ libavcodec/flacenc.c	(working copy)
@@ -22,6 +22,7 @@
 #include "crc.h"
 #include "golomb.h"
 #include "lls.h"
+#include "md5.h"
 
 #define FLAC_MAX_CH  8
 #define FLAC_MIN_BLOCKSIZE  16
@@ -104,6 +105,7 @@
     uint32_t frame_count;
     FlacFrame frame;
     CompressionOptions options;
+    struct AVMD5 *md5ctx;
     AVCodecContext *avctx;
 } FlacEncodeContext;
 
@@ -387,6 +389,9 @@
     avctx->extradata = streaminfo;
     avctx->extradata_size = FLAC_STREAMINFO_SIZE;
 
+    s->md5ctx = av_malloc(av_md5_size);
+    av_md5_init(s->md5ctx);
+
     s->frame_count = 0;
 
     avctx->coded_frame = avcodec_alloc_frame();
@@ -1312,6 +1317,32 @@
     flush_put_bits(&s->pb);
 }
 
+/**
+ * Update the MD5 sum with the input audio data
+ */
+static void md5_accumulate(struct AVMD5 *md5, uint8_t *sum,
+                           void *signal, int ch, int nsamples)
+{
+    int data_bytes = ch * nsamples * 2;
+
+    if(data_bytes <= 0) {
+        av_md5_final(md5, sum);
+    } else {
+#ifdef WORDS_BIGENDIAN
+        int i;
+        uint16_t *sig16 = av_malloc(data_bytes);
+        memcpy(sig16, signal, data_bytes);
+        for(i=0; i<nsamples*ch; i++) {
+            sig16[i] = bswap_16(sig16[i]);
+        }
+        av_md5_update(md5, sig16, data_bytes);
+        av_freep(&sig16);
+#else
+        av_md5_update(md5, signal, data_bytes);
+#endif
+    }
+}
+
 static int flac_encode_frame(AVCodecContext *avctx, uint8_t *frame,
                              int buf_size, void *data)
 {
@@ -1322,9 +1353,16 @@
 
     s = avctx->priv_data;
 
+    if(data == NULL) {
+        md5_accumulate(s->md5ctx, avctx->checksum, NULL, s->channels, 0);
+        return 0;
+    }
+
     s->blocksize = avctx->frame_size;
     init_frame(s);
 
+    md5_accumulate(s->md5ctx, NULL, samples, s->channels, s->blocksize);
+
     copy_samples(s, samples);
 
     channel_decorrelation(s);
@@ -1340,6 +1378,8 @@
 
     if(out_bytes > s->max_framesize || out_bytes >= buf_size) {
         /* frame too large. use verbatim mode */
+        copy_samples(s, samples);
+        channel_decorrelation(s);
         for(ch=0; ch<s->channels; ch++) {
             encode_residual_v(s, ch);
         }
@@ -1362,6 +1402,10 @@
 
 static int flac_encode_close(AVCodecContext *avctx)
 {
+    FlacEncodeContext *s = avctx->priv_data;
+    if(s != NULL) {
+        av_freep(&s->md5ctx);
+    }
     av_freep(&avctx->extradata);
     avctx->extradata_size = 0;
     av_freep(&avctx->coded_frame);
@@ -1377,5 +1421,5 @@
     flac_encode_frame,
     flac_encode_close,
     NULL,
-    .capabilities = CODEC_CAP_SMALL_LAST_FRAME,
+    .capabilities = CODEC_CAP_DELAY | CODEC_CAP_SMALL_LAST_FRAME,
 };
Index: tests/rotozoom.regression.ref
===================================================================
--- tests/rotozoom.regression.ref	(revision 5969)
+++ tests/rotozoom.regression.ref	(working copy)
@@ -176,7 +176,7 @@
 264236 ./data/a-adpcm_yam.wav
 e92cec8c07913ffb91ad2b11f79cdc00 *./data/out.wav
 stddev:18312.68 PSNR:11.06 bytes:1056768
-c3382f03ce2efb5d475240d288a33898 *./data/a-flac.flac
-353368 ./data/a-flac.flac
+355a7b59e6a5b36fef86b55a9dcff3b7 *./data/a-flac.flac
+357486 ./data/a-flac.flac
 c4228df189aad9567a037727d0e763e4 *./data/out.wav
 stddev: 33.31 PSNR:65.87 bytes:1040384
Index: tests/ffmpeg.regression.ref
===================================================================
--- tests/ffmpeg.regression.ref	(revision 5969)
+++ tests/ffmpeg.regression.ref	(working copy)
@@ -176,7 +176,7 @@
 264236 ./data/a-adpcm_yam.wav
 e92cec8c07913ffb91ad2b11f79cdc00 *./data/out.wav
 stddev:18312.68 PSNR:11.06 bytes:1056768
-c3382f03ce2efb5d475240d288a33898 *./data/a-flac.flac
-353368 ./data/a-flac.flac
+355a7b59e6a5b36fef86b55a9dcff3b7 *./data/a-flac.flac
+357486 ./data/a-flac.flac
 c4228df189aad9567a037727d0e763e4 *./data/out.wav
 stddev: 33.31 PSNR:65.87 bytes:1040384
Index: libavformat/Makefile
===================================================================
--- libavformat/Makefile	(revision 5969)
+++ libavformat/Makefile	(working copy)
@@ -89,7 +89,7 @@
 OBJS-$(CONFIG_STR_DEMUXER)               += psxstr.o
 OBJS-$(CONFIG_SHORTEN_DEMUXER)           += raw.o
 OBJS-$(CONFIG_FLAC_DEMUXER)              += raw.o
-OBJS-$(CONFIG_FLAC_MUXER)                += raw.o
+OBJS-$(CONFIG_FLAC_MUXER)                += rawflacenc.o
 OBJS-$(CONFIG_AC3_DEMUXER)               += raw.o
 OBJS-$(CONFIG_AC3_MUXER)                 += raw.o
 OBJS-$(CONFIG_DTS_DEMUXER)               += raw.o
Index: libavformat/raw.c
===================================================================
--- libavformat/raw.c	(revision 5969)
+++ libavformat/raw.c	(working copy)
@@ -26,20 +26,6 @@
     return 0;
 }
 
-static int flac_write_header(struct AVFormatContext *s)
-{
-    static const uint8_t header[8] = {
-        0x66, 0x4C, 0x61, 0x43, 0x80, 0x00, 0x00, 0x22
-    };
-    uint8_t *streaminfo = s->streams[0]->codec->extradata;
-    int len = s->streams[0]->codec->extradata_size;
-    if(streaminfo != NULL && len > 0) {
-        put_buffer(&s->pb, header, 8);
-        put_buffer(&s->pb, streaminfo, len);
-    }
-    return 0;
-}
-
 static int raw_write_packet(struct AVFormatContext *s, AVPacket *pkt)
 {
     put_buffer(&s->pb, pkt->data, pkt->size);
@@ -411,21 +397,6 @@
     .extensions = "flac",
 };
 
-#ifdef CONFIG_MUXERS
-AVOutputFormat flac_muxer = {
-    "flac",
-    "raw flac",
-    "audio/x-flac",
-    "flac",
-    0,
-    CODEC_ID_FLAC,
-    0,
-    flac_write_header,
-    raw_write_packet,
-    raw_write_trailer,
-    .flags= AVFMT_NOTIMESTAMPS,
-};
-#endif //CONFIG_MUXERS
 
 AVInputFormat ac3_demuxer = {
     "ac3",
Index: libavformat/rawflacenc.c
===================================================================
--- libavformat/rawflacenc.c	(revision 0)
+++ libavformat/rawflacenc.c	(revision 0)
@@ -0,0 +1,261 @@
+/**
+ * raw FLAC muxer
+ * Copyright (c) 2006 Justin Ruggles <jruggle@earthlink.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file rawflacenc.c
+ * raw FLAC muxer.
+ */
+
+#include "version.h"
+#include "avformat.h"
+#include "bitstream.h"
+
+#define STREAMINFO_HEADER_SIZE 34
+
+#define DEFAULT_PADDING_SIZE 4096
+
+#define VENDOR_STRING "FFmpeg version " FFMPEG_VERSION
+#define VENDOR_STRING_BITEXACT "FFmpeg"
+
+#define METADATA_TYPE_STREAMINFO        0
+#define METADATA_TYPE_PADDING           1
+#define METADATA_TYPE_APPLICATION       2
+#define METADATA_TYPE_SEEKTABLE         3
+#define METADATA_TYPE_VORBIS_COMMENT    4
+#define METADATA_TYPE_CUESHEET          5
+#define METADATA_TYPE_INVALID         127
+
+#define FLAG_LAST_BLOCK 0x80
+
+typedef struct {
+    AVCodecContext *avctx;
+    int extra_blocks;
+    int needed_blocks;
+    int has_padding;
+    int has_seektable;
+    int has_vorbis_comment;
+    uint64_t sample_count;
+} FLACContext;
+
+static int parse_extradata(FLACContext *flac, uint8_t *data, int size)
+{
+    int srate, ch, blk_type, blk_len, last_pos;
+    ByteIOContext gb;
+
+    if(size < STREAMINFO_HEADER_SIZE) {
+        return -1;
+    }
+
+    url_open_buf(&gb, data, size, URL_RDWR);
+
+    // quick and dirty streaminfo validation
+    url_fskip(&gb, 10);
+    srate = get_be24(&gb);
+    ch = ((srate >> 1) & 0x7) + 1;
+    srate >>= 4;
+    if((flac->avctx->sample_rate != srate) || (flac->avctx->channels != ch)) {
+        return -1;
+    }
+    url_fskip(&gb, 21);
+
+    last_pos = 0;
+    if(size > STREAMINFO_HEADER_SIZE) {
+        blk_type = url_fgetc(&gb);
+        while(blk_type != URL_EOF) {
+            last_pos = url_ftell(&gb)-1;
+            switch(blk_type & 0x7F) {
+                case METADATA_TYPE_STREAMINFO:
+                    // 1 and only 1 streaminfo block is required
+                    return -1;
+                case METADATA_TYPE_PADDING:
+                    flac->has_padding = 1;
+                    break;
+                case METADATA_TYPE_SEEKTABLE:
+                    // only 1 seektable block is allowed
+                    if(flac->has_seektable)
+                        return -1;
+                    flac->has_seektable = 1;
+                    break;
+                case METADATA_TYPE_VORBIS_COMMENT:
+                    // only 1 vorbis comment block is allowed
+                    if(flac->has_vorbis_comment)
+                        return -1;
+                    flac->has_vorbis_comment = 1;
+                    break;
+                case METADATA_TYPE_INVALID:
+                    return -1;
+            }
+            blk_len = get_be24(&gb);
+            url_fskip(&gb, blk_len);
+            flac->extra_blocks++;
+    
+            if(!(blk_type & FLAG_LAST_BLOCK)) break;
+            blk_type = url_fgetc(&gb);
+        }
+    }
+    // set 'last' flag if we aren't adding any new blocks
+    flac->needed_blocks = 0;
+    if(!flac->has_padding) flac->needed_blocks++;
+    if(!flac->has_vorbis_comment) flac->needed_blocks++;
+    if(!flac->needed_blocks && last_pos > 0) {
+        data[last_pos] |= FLAG_LAST_BLOCK;
+    }
+
+    return 0;
+}
+
+static int flac_write_header(struct AVFormatContext *s)
+{
+    FLACContext *flac = s->priv_data;
+    ByteIOContext *pb = &s->pb;
+    AVCodecContext *avc = s->streams[0]->codec;
+
+    if(s->streams[0]->stream_copy || avc->extradata == NULL ||
+            avc->extradata_size <= 0) {
+        return 0;
+    }
+    memset(flac, 0, sizeof(FLACContext));
+    flac->avctx = avc;
+
+    if(parse_extradata(flac, avc->extradata, avc->extradata_size)) {
+        av_log(s, AV_LOG_ERROR, "invalid codec extradata\n");
+        return -1;
+    }
+
+    // write 'fLaC' stream marker
+    put_be32(pb, 0x664C6143);
+
+    // write streaminfo & extra blocks
+    if(!flac->extra_blocks && !flac->needed_blocks) {
+        put_byte(pb, FLAG_LAST_BLOCK | METADATA_TYPE_STREAMINFO);
+    } else {
+        put_byte(pb, METADATA_TYPE_STREAMINFO);
+    }
+    put_be24(pb, STREAMINFO_HEADER_SIZE);
+    put_buffer(pb, avc->extradata, avc->extradata_size);
+    if(!flac->needed_blocks) {
+        put_flush_packet(pb);
+        return 0;
+    }
+
+    // write vorbis comment block
+    if(flac->needed_blocks && !flac->has_vorbis_comment) {
+        char *vendor = VENDOR_STRING;
+        int vendor_len;
+
+        if(avc->flags & CODEC_FLAG_BITEXACT) {
+            vendor = VENDOR_STRING_BITEXACT;
+        }
+        vendor_len = strlen(vendor);
+
+        if(flac->needed_blocks == 1) {
+            put_byte(pb, FLAG_LAST_BLOCK | METADATA_TYPE_VORBIS_COMMENT);
+        } else {
+            put_byte(pb, METADATA_TYPE_VORBIS_COMMENT);
+        }
+        flac->needed_blocks--;
+
+        put_be24(pb, vendor_len+8);
+        put_le32(pb, vendor_len);
+        put_buffer(pb, vendor, vendor_len);
+        put_le32(pb, 0);
+    }
+
+    // write padding block
+    if(flac->needed_blocks && !flac->has_padding) {
+        int i, pad_len;
+
+        pad_len = DEFAULT_PADDING_SIZE;
+
+        if(flac->needed_blocks == 1) {
+            put_byte(pb, FLAG_LAST_BLOCK | METADATA_TYPE_PADDING);
+        } else {
+            put_byte(pb, METADATA_TYPE_PADDING);
+        }
+        flac->needed_blocks--;
+
+        put_be24(pb, pad_len);
+        for(i=0; i<pad_len; i++) {
+            put_byte(pb, 0);
+        }
+    }
+
+    put_flush_packet(pb);
+    return 0;
+}
+
+static int flac_write_trailer(struct AVFormatContext *s)
+{
+    FLACContext *flac = s->priv_data;
+    AVCodecContext *avctx = s->streams[0]->codec;
+    ByteIOContext *pb = &s->pb;
+    offset_t file_pos;
+
+    // seek to header and rewrite sample count
+    if(!url_is_streamed(pb)) {
+        file_pos = url_ftell(pb);
+        url_fseek(pb, 22, SEEK_SET);
+
+        // FIXME: The sample count field is not byte-aligned, so we're only
+        // writing the least 32-bits of the 36-bit field. This limits the
+        // encoded playing time to ~25 hours at 48kHz or ~27 hours at 44.1kHz.
+        flac->sample_count = FFMIN(flac->sample_count, 0xFFFFFFFFUL);
+        put_be32(pb, (uint32_t)flac->sample_count);
+
+        // write MD5 sum
+        put_buffer(pb, avctx->checksum, 16);
+
+        url_fseek(pb, file_pos, SEEK_SET);
+        put_flush_packet(pb);
+    }
+    return 0;
+}
+
+static int flac_write_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    FLACContext *flac = s->priv_data;
+    AVStream *st = s->streams[0];
+
+    // keep current count of audio samples
+    if(pkt->pts != AV_NOPTS_VALUE) {
+        flac->sample_count = (float)(pkt->pts+pkt->duration) *
+                             (float)st->time_base.num /
+                             (float)st->time_base.den *
+                             (float)st->codec->sample_rate + 0.5;
+    } else {
+        flac->sample_count = 0;
+    }
+
+    put_buffer(&s->pb, pkt->data, pkt->size);
+    put_flush_packet(&s->pb);
+    return 0;
+}
+
+AVOutputFormat flac_muxer = {
+    "flac",
+    "raw flac",
+    "audio/x-flac",
+    "flac",
+    sizeof(FLACContext),
+    CODEC_ID_FLAC,
+    CODEC_ID_NONE,
+    flac_write_header,
+    flac_write_packet,
+    flac_write_trailer,
+};
